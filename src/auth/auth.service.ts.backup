import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Redis } from '@upstash/redis';
import { Page } from 'puppeteer';
import { BrowserService } from '../browser/browser.service';

export interface LoginStatus {
  isLoggedIn: boolean;
  lastChecked: Date;
  cookiesExpireAt?: Date;
  error?: string;
}

interface QrLoginSession {
  page: Page;
  qrCodeUrl: string;
  createdAt: Date;
  isMonitoring: boolean;
}

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  private redis: Redis;
  private readonly REDIS_KEY = 'xiaohongshu:auth';
  private readonly COOKIES_KEY = 'xiaohongshu:cookies';
  private readonly XHS_LOGIN_URL = 'https://www.xiaohongshu.com/explore';
  private readonly COOKIE_EXPIRE_DAYS = 7; // Cookieä¿å­˜7å¤©
  
  // é¡µé¢çŠ¶æ€ç®¡ç†
  private currentQrSession: QrLoginSession | null = null;
  private readonly QR_CODE_EXPIRE_TIME = 300000; // äºŒç»´ç 5åˆ†é’Ÿè¿‡æœŸï¼Œç»™ç”¨æˆ·è¶³å¤Ÿæ—¶é—´
  private readonly LOGIN_CHECK_XPATH = '//*[@id="app"]/div[1]/div/div[1]/div[3]/div[1]'; // ç™»å½•ç•Œé¢ç‰¹æœ‰å…ƒç´ 

  constructor(
    private browserService: BrowserService,
    private configService: ConfigService,
  ) {
    this.initRedis();
    
    // ä¸åœ¨æœåŠ¡å¯åŠ¨æ—¶æ£€æŸ¥ç™»å½•çŠ¶æ€ï¼Œé¿å…ä¸å¿…è¦çš„Redisè¯»å–é”™è¯¯
    // åªåœ¨å®é™…éœ€è¦æ—¶æ‰è¯»å–å‡­è¯
  }

  private initRedis() {
    const upstashUrl = this.configService.get<string>('UPSTASH_REDIS_REST_URL');
    const upstashToken = this.configService.get<string>('UPSTASH_REDIS_REST_TOKEN');

    if (!upstashUrl || !upstashToken) {
      throw new Error('Upstash Redis URL and Token must be provided');
    }

    this.redis = new Redis({
      url: upstashUrl,
      token: upstashToken,
    });

    this.logger.log('[REDIS] âœ… Upstash Redis client initialized successfully');
  }

  // æœåŠ¡å¯åŠ¨æ—¶åˆå§‹åŒ–ç™»å½•çŠ¶æ€
  private async initializeLoginStatus(): Promise<void> {
    try {
      this.logger.log('ğŸš€ [INIT] Initializing login status on service startup...');
      
      // æ£€æŸ¥æ˜¯å¦æœ‰å®Œæ•´çš„ä¿å­˜å‡­è¯ï¼ˆcookiesã€localStorageã€sessionStorageï¼‰
      const savedCookies = await this.loadCookiesFromRedis();
      const hasLocalStorage = await this.redis.get('xiaohongshu:localStorage');
      const hasSessionStorage = await this.redis.get('xiaohongshu:sessionStorage');
      
      if (savedCookies && savedCookies.length > 0) {
        this.logger.log(`ğŸ” [INIT] Found saved credentials:`);
        this.logger.log(`  ğŸª Cookies: ${savedCookies.length} items`);
        this.logger.log(`  ğŸ—ƒï¸ LocalStorage: ${hasLocalStorage ? 'Available' : 'None'}`);
        this.logger.log(`  ğŸ“¦ SessionStorage: ${hasSessionStorage ? 'Available' : 'None'}`);
        
        // éªŒè¯å‡­è¯æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        this.logger.log('ğŸ” [INIT] Verifying saved credentials...');
        const isLoggedIn = await this.checkLoginStatus();
        
        if (isLoggedIn) {
          this.logger.log('âœ… [INIT] Login status recovered successfully from saved credentials');
          this.logger.log('ğŸ‰ [INIT] User can start using the system without logging in again!');
        } else {
          this.logger.warn('âŒ [INIT] Saved credentials are invalid, user will need to login again');
          await this.clearAllAuthData();
        }
      } else {
        this.logger.log('âšª [INIT] No saved credentials found, user will need to login');
        await this.saveLoginStatus({
          isLoggedIn: false,
          lastChecked: new Date(),
        });
      }
    } catch (error) {
      this.logger.error('âŒ [INIT] Failed to initialize login status:', error);
    }
  }

  async getLoginStatus(): Promise<LoginStatus> {
    // é¦–å…ˆæ£€æŸ¥å½“å‰ä¼šè¯æ˜¯å¦æœ‰ç™»å½•
    if (this.currentQrSession) {
      const sessionLogin = await this.checkCurrentSessionLogin();
      if (sessionLogin) {
        // å¦‚æœä¼šè¯ä¸­æ£€æµ‹åˆ°ç™»å½•ï¼Œè¿”å›æœ€æ–°çŠ¶æ€
        return {
          isLoggedIn: true,
          lastChecked: new Date(),
          cookiesExpireAt: new Date(Date.now() + this.COOKIE_EXPIRE_DAYS * 24 * 60 * 60 * 1000),
        };
      }
    }

    try {
      const statusStr = await this.redis.get(this.REDIS_KEY);
      if (statusStr) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„ JSON å­—ç¬¦ä¸²
        if (typeof statusStr === 'string' && statusStr.startsWith('{')) {
          const parsed = JSON.parse(statusStr);
          // éªŒè¯è§£æåçš„å¯¹è±¡åŒ…å«å¿…è¦çš„å­—æ®µ
          if (parsed && typeof parsed.isLoggedIn === 'boolean') {
            return {
              ...parsed,
              lastChecked: new Date(parsed.lastChecked),
              cookiesExpireAt: parsed.cookiesExpireAt ? new Date(parsed.cookiesExpireAt) : undefined,
            };
          }
        }
        
        // å¦‚æœæ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œæ¸…é™¤å¹¶è®°å½•
        this.logger.warn(`Invalid login status data in Redis: ${statusStr}, clearing...`);
        await this.redis.del(this.REDIS_KEY);
      }
    } catch (error) {
      this.logger.error('Failed to get login status from Redis:', error);
      // æ¸…é™¤æŸåçš„æ•°æ®
      try {
        await this.redis.del(this.REDIS_KEY);
        this.logger.log('Cleared corrupted login status data from Redis');
      } catch (cleanupError) {
        this.logger.error('Failed to cleanup corrupted data:', cleanupError);
      }
    }

    return {
      isLoggedIn: false,
      lastChecked: new Date(),
    };
  }

  async saveLoginStatus(status: LoginStatus): Promise<void> {
    try {
      // ç¡®ä¿æ—¥æœŸå¯¹è±¡è¢«æ­£ç¡®åºåˆ—åŒ–
      const statusToSave = {
        isLoggedIn: status.isLoggedIn,
        lastChecked: status.lastChecked.toISOString(),
        cookiesExpireAt: status.cookiesExpireAt ? status.cookiesExpireAt.toISOString() : undefined,
        error: status.error,
      };
      
      const jsonString = JSON.stringify(statusToSave);
      await this.redis.setex(this.REDIS_KEY, 3600 * 24, jsonString); // 24å°æ—¶è¿‡æœŸ
      
      this.logger.log(`Saved login status to Redis: ${jsonString}`);
    } catch (error) {
      this.logger.error('Failed to save login status to Redis:', error);
    }
  }

  // ä¿å­˜Cookiesåˆ°Redis
  async saveCookiesToRedis(cookies: any[]): Promise<void> {
    try {
      const expireSeconds = this.COOKIE_EXPIRE_DAYS * 24 * 3600;
      await this.redis.setex(this.COOKIES_KEY, expireSeconds, JSON.stringify(cookies));
      
      const expireDate = new Date();
      expireDate.setDate(expireDate.getDate() + this.COOKIE_EXPIRE_DAYS);
      
      this.logger.log(`Saved ${cookies.length} cookies to Redis, expires at: ${expireDate.toISOString()}`);
    } catch (error) {
      this.logger.error('Failed to save cookies to Redis:', error);
    }
  }

  // ä»RedisåŠ è½½Cookies
  async loadCookiesFromRedis(): Promise<any[] | null> {
    try {
      const cookiesStr = await this.redis.get(this.COOKIES_KEY);
      if (cookiesStr) {
        // æ£€æŸ¥æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®
        if (typeof cookiesStr === 'string' && cookiesStr.startsWith('[')) {
          const cookies = JSON.parse(cookiesStr);
          this.logger.log(`ğŸ”„ [LOAD] Loaded ${cookies.length} cookies from Redis`);
          return cookies;
        } else {
          this.logger.warn('âš ï¸ [LOAD] Invalid cookie data format in Redis, clearing...');
          await this.redis.del(this.COOKIES_KEY);
          return null;
        }
      }
      this.logger.log('âšª [LOAD] No cookies found in Redis');
      return null;
    } catch (error) {
      this.logger.error('âŒ [LOAD] Failed to load cookies from Redis:', error);
      // æ¸…é™¤æŸåçš„æ•°æ®
      try {
        await this.redis.del(this.COOKIES_KEY);
        this.logger.log('ğŸ—‘ï¸ [LOAD] Cleared corrupted cookie data from Redis');
      } catch (cleanupError) {
        this.logger.error('âŒ [LOAD] Failed to cleanup corrupted cookie data:', cleanupError);
      }
      return null;
    }
  }

  // æ¸…é™¤ä¿å­˜çš„Cookies
  async clearCookiesFromRedis(): Promise<void> {
    try {
      await this.redis.del(this.COOKIES_KEY);
      this.logger.log('Cleared cookies from Redis');
    } catch (error) {
      this.logger.error('Failed to clear cookies from Redis:', error);
    }
  }

  async checkLoginStatus(): Promise<boolean> {
    const page = await this.browserService.createPage();
    
    try {
      this.logger.log('ğŸ” [CHECK] Starting login status check...');

      // åŠ è½½æ‰€æœ‰ä¿å­˜çš„å‡­è¯
      await this.loadSavedCredentials(page);

      await page.goto(this.XHS_LOGIN_URL, { waitUntil: 'networkidle2', timeout: 30000 });

      // ç­‰å¾…é¡µé¢ç¨³å®š
      await page.waitForTimeout(2000);

      // ä½¿ç”¨ç²¾ç¡®çš„XPathæ£€æµ‹æ˜¯å¦éœ€è¦ç™»å½•
      const needLogin = await this.isLoginRequired(page);

      const expireDate = new Date();
      expireDate.setDate(expireDate.getDate() + this.COOKIE_EXPIRE_DAYS);

      const status: LoginStatus = {
        isLoggedIn: !needLogin,
        lastChecked: new Date(),
        cookiesExpireAt: needLogin ? undefined : expireDate,
      };

      if (!needLogin) {
        // å¦‚æœå·²ç™»å½•ï¼Œä¿å­˜æœ€æ–°çš„å‡­è¯
        const currentCookies = await page.cookies();
        if (currentCookies.length > 0) {
          await this.saveCredentials(page, currentCookies);
        }
        this.logger.log('âœ… [CHECK] Login status verified: LOGGED IN');
      } else {
        // å¦‚æœéœ€è¦ç™»å½•ï¼Œæ¸…é™¤æ— æ•ˆçš„å‡­è¯
        await this.clearAllAuthData();
        this.logger.log('âŒ [CHECK] Login status verified: NOT LOGGED IN');
      }

      await this.saveLoginStatus(status);
      return !needLogin;

    } catch (error) {
      this.logger.error('âŒ [CHECK] Failed to check login status:', error);
      await this.saveLoginStatus({
        isLoggedIn: false,
        lastChecked: new Date(),
        error: error.message,
      });
      return false;
    } finally {
      await page.close();
    }
  }

  async startLoginProcess(): Promise<{ qrCodeUrl?: string; error?: string }> {
    // æ£€æŸ¥å½“å‰ä¼šè¯æ˜¯å¦æœ‰æ•ˆ
    if (this.isQrSessionValid()) {
      this.logger.log('Reusing existing valid QR code session');
      return { qrCodeUrl: this.currentQrSession!.qrCodeUrl };
    }

    // æ¸…ç†æ— æ•ˆçš„ä¼šè¯
    await this.cleanupQrSession();

    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ä¿å­˜çš„æœ‰æ•ˆå‡­è¯
    this.logger.log('ğŸ”„ [START_LOGIN] Checking for existing valid credentials...');
    try {
      const hasValidCredentials = await this.checkLoginStatus();
      if (hasValidCredentials) {
        this.logger.log('âœ… [START_LOGIN] Found valid credentials, user is already logged in!');
        return { error: 'User is already logged in with saved credentials' };
      }
    } catch (error) {
      this.logger.warn('âš ï¸ [START_LOGIN] Error checking existing credentials:', error);
    }

    this.logger.log('Creating new QR code session...');
    const page = await this.browserService.createPage();
    
    try {
      // åœ¨å¯¼èˆªä¹‹å‰ï¼Œå…ˆå°è¯•åŠ è½½ä¿å­˜çš„å‡­è¯
      this.logger.log('ğŸ”„ [START_LOGIN] Loading any saved credentials before navigation...');
      await this.loadSavedCredentials(page);
      
      this.logger.log('Navigating to Xiaohongshu login page...');
      await page.goto(this.XHS_LOGIN_URL, { waitUntil: 'networkidle2', timeout: 30000 });

      // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
      await page.waitForTimeout(3000);
      
      // å†æ¬¡æ£€æŸ¥æ˜¯å¦å› ä¸ºåŠ è½½çš„å‡­è¯è€Œå·²ç»ç™»å½•
      const isLoggedInAfterNavigation = !(await this.isLoginRequired(page));
      if (isLoggedInAfterNavigation) {
        this.logger.log('ğŸ‰ [START_LOGIN] User is already logged in after loading credentials!');
        await page.close();
        return { error: 'User is already logged in' };
      }

      // ç­‰å¾…äºŒç»´ç å‡ºç° - ä½¿ç”¨å¤šç§é€‰æ‹©å™¨
      const qrCodeSelectors = [
        '//*[@id="app"]/div[1]/div/div[1]/div[2]/div[2]/div[2]/img',
        '//img[contains(@alt, "äºŒç»´ç ")]',
        '//img[contains(@src, "qrcode")]',
        '.qr-code img',
        '.qrcode img',
      ];
      
      let qrCodeElement: any = null;
      let qrCodeUrl: string | null = null;

      for (const selector of qrCodeSelectors) {
        try {
          this.logger.log(`Trying selector: ${selector}`);
          
          if (selector.startsWith('//')) {
            // XPath selector
            await page.waitForXPath(selector, { timeout: 5000 });
            const elements = await page.$x(selector);
            if (elements.length > 0) {
              qrCodeElement = elements[0];
              break;
            }
          } else {
            // CSS selector
            await page.waitForSelector(selector, { timeout: 5000 });
            qrCodeElement = await page.$(selector);
            if (qrCodeElement) {
              break;
            }
          }
        } catch (error) {
          this.logger.warn(`Selector ${selector} not found, trying next...`);
          continue;
        }
      }

      if (qrCodeElement) {
        try {
          // å°è¯•è·å–äºŒç»´ç å›¾ç‰‡çš„ src å±æ€§
          qrCodeUrl = await page.evaluate((element: HTMLImageElement) => {
            return element.src;
          }, qrCodeElement);
          
          this.logger.log(`QR code URL extracted: ${qrCodeUrl ? 'Success' : 'Failed'}`);
          
          if (qrCodeUrl) {
            // åˆ›å»ºæ–°çš„ä¼šè¯
            this.currentQrSession = {
              page,
              qrCodeUrl,
              createdAt: new Date(),
              isMonitoring: false,
            };

            // æ ‡è®°ç›‘å¬å·²å¯åŠ¨ï¼Œä½†ä¸è¿›è¡Œä»»ä½•è‡ªåŠ¨æ“ä½œ
            this.startLoginMonitoring();
            
            this.logger.log('New QR code session created successfully');
            return { qrCodeUrl };
          }
        } catch (error) {
          this.logger.error('Failed to extract QR code URL:', error);
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°äºŒç»´ç ï¼Œå°è¯•æˆªå›¾è·å–æ›´å¤šä¿¡æ¯
      try {
        await page.screenshot({ 
          path: 'debug-login-page.png',
          fullPage: true 
        });
        this.logger.log('Debug screenshot saved as debug-login-page.png');
      } catch (error) {
        this.logger.warn('Could not save debug screenshot:', error);
      }

      await page.close();
      return { error: 'æ— æ³•è·å–ç™»å½•äºŒç»´ç ï¼Œå¯èƒ½é¡µé¢ç»“æ„å·²å˜åŒ–' };

    } catch (error) {
      this.logger.error('Failed to start login process:', error);
      await page.close();
      return { error: error.message };
    }
  }

  // å¯åŠ¨ä¸»åŠ¨çš„ç™»å½•ç›‘å¬ï¼Œæ£€æµ‹äºŒç»´ç å¼¹çª—æ¶ˆå¤±
  private async startLoginMonitoring(): Promise<void> {
    if (!this.currentQrSession || this.currentQrSession.isMonitoring) {
      this.logger.warn('Cannot start monitoring: no session or already monitoring');
      return;
    }

    this.currentQrSession.isMonitoring = true;
    this.logger.log('ğŸ” [LOGIN] Starting QR code login monitoring...');
    this.logger.log('ğŸ“± [LOGIN] Please scan the QR code with Xiaohongshu app and confirm on your phone');
    
    // å¯åŠ¨åå°ç›‘å¬ä»»åŠ¡
    this.monitorQrCodeDisappearance();
  }

  // ç›‘å¬äºŒç»´ç å¼¹çª—çš„æ¶ˆå¤±ï¼Œæ£€æµ‹ç™»å½•æˆåŠŸ
  private async monitorQrCodeDisappearance(): Promise<void> {
    if (!this.currentQrSession) {
      return;
    }

    const page = this.currentQrSession.page;
    const timeout = this.configService.get<number>('XHS_LOGIN_TIMEOUT', 300000); // 5åˆ†é’Ÿè¶…æ—¶
    const startTime = Date.now();
    const checkInterval = 5000; // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œç»™ç”¨æˆ·å……è¶³ç¡®è®¤æ—¶é—´

    this.logger.log('ğŸ” [LOGIN] Monitoring QR code popup disappearance...');

    try {
      let loginDetected = false;

      while (Date.now() - startTime < timeout && !loginDetected && this.currentQrSession) {
        try {
          // 1. æ£€æŸ¥äºŒç»´ç å…ƒç´ æ˜¯å¦è¿˜å­˜åœ¨
          const qrCodeExists = await page.evaluate(() => {
            const qrSelectors = [
              'img[alt*="äºŒç»´ç "]',
              'img[src*="qrcode"]', 
              '.qr-code img',
              '.qrcode img',
              '[class*="qr"]',
              '[class*="QR"]'
            ];
            
            return qrSelectors.some(selector => {
              const element = document.querySelector(selector) as HTMLElement;
              return element && element.offsetParent !== null; // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
            });
          });

          // 2. æ£€æŸ¥ç™»å½•å¼¹çª—/å®¹å™¨æ˜¯å¦è¿˜å­˜åœ¨
          const loginModalExists = await page.evaluate(() => {
            const modalSelectors = [
              '.login-container',
              '.signin-container', 
              '[class*="login"]',
              '[class*="signin"]',
              '[class*="modal"]'
            ];
            
            return modalSelectors.some(selector => {
              const element = document.querySelector(selector) as HTMLElement;
              return element && element.offsetParent !== null;
            });
          });

          this.logger.log(`ğŸ” [LOGIN] QR Code exists: ${qrCodeExists}, Login modal exists: ${loginModalExists}`);

          // 3. å¦‚æœäºŒç»´ç æ¶ˆå¤±æˆ–ç™»å½•å¼¹çª—æ¶ˆå¤±ï¼Œè¯´æ˜å¯èƒ½ç™»å½•æˆåŠŸ
          if (!qrCodeExists || !loginModalExists) {
            this.logger.log('ğŸ‰ [LOGIN] QR code popup disappeared! Waiting for user to confirm login...');
            
            // ç»™ç”¨æˆ·5ç§’æ—¶é—´ç‚¹å‡»ç¡®è®¤ç™»å½•
            this.logger.log('â³ [LOGIN] Waiting 5 seconds for user to confirm login on phone...');
            await page.waitForTimeout(5000);
            
            // éªŒè¯ç™»å½•æ˜¯å¦çœŸæ­£æˆåŠŸ
            const loginSuccess = await this.validateLoginSuccess(page);
            if (loginSuccess) {
              loginDetected = true;
              break;
            } else {
              this.logger.warn('âš ï¸ [LOGIN] User may still be confirming login, continuing monitoring...');
            }
          }

          // 4. æ£€æŸ¥URLæ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼ˆå¤‡ç”¨æ£€æµ‹æ–¹æ³•ï¼‰
          const currentUrl = page.url();
          if (!currentUrl.includes('signin') && !currentUrl.includes('login') && currentUrl.includes('xiaohongshu.com')) {
            this.logger.log('ğŸŒ [LOGIN] Page URL changed, verifying login...');
            const loginSuccess = await this.validateLoginSuccess(page);
            if (loginSuccess) {
              loginDetected = true;
              break;
            }
          }

          await page.waitForTimeout(checkInterval);

        } catch (error) {
          this.logger.warn(`âš ï¸ [LOGIN] Error during monitoring: ${error.message}`);
          await page.waitForTimeout(checkInterval);
        }
      }

      if (!loginDetected) {
        if (Date.now() - startTime >= timeout) {
          this.logger.warn('â° [LOGIN] QR code login monitoring timeout');
        } else {
          this.logger.warn('ğŸ›‘ [LOGIN] QR code login monitoring stopped');
        }
      }

    } catch (error) {
      this.logger.error('âŒ [LOGIN] QR code monitoring failed:', error);
    }
  }

  // éªŒè¯ç™»å½•æ˜¯å¦çœŸæ­£æˆåŠŸï¼Œå¹¶ä¿å­˜å‡­è¯
  private async validateLoginSuccess(page: Page): Promise<boolean> {
    try {
      this.logger.log('ğŸ” [LOGIN] Validating login success...');

      // 1. ä½¿ç”¨ç²¾ç¡®çš„XPathæ£€æµ‹æ˜¯å¦ä»éœ€è¦ç™»å½•
      const stillNeedsLogin = await this.isLoginRequired(page);
      
      if (stillNeedsLogin) {
        this.logger.log('âš ï¸ [LOGIN] User still on login page, not logged in yet');
        return false;
      }

      this.logger.log('âœ… [LOGIN] Login page element not found - user appears to be logged in!');

      // 2. æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„è®¤è¯cookies
      const cookies = await page.cookies();
      this.logger.log(`ğŸª [LOGIN] Found ${cookies.length} total cookies`);

      if (cookies.length === 0) {
        this.logger.warn('âš ï¸ [LOGIN] No cookies found, this may be an issue');
        return false;
      }

      // 3. ä¿å­˜æ‰€æœ‰å‡­è¯æ•°æ®
      await this.saveCredentials(page, cookies);

      // 4. ä½¿ç”¨æ–°çš„é¡µé¢éªŒè¯ç™»å½•çŠ¶æ€
      const isValid = await this.verifyLoginWithNewPage(cookies);
      
      if (isValid) {
        this.logger.log('âœ… [LOGIN] Login validation successful! Credentials saved.');
        
        const expireDate = new Date();
        expireDate.setDate(expireDate.getDate() + this.COOKIE_EXPIRE_DAYS);
        
        await this.saveLoginStatus({
          isLoggedIn: true,
          lastChecked: new Date(),
          cookiesExpireAt: expireDate,
        });

        // æ¸…ç†ä¼šè¯
        await this.cleanupQrSession();
        
        return true;
      } else {
        this.logger.warn('âŒ [LOGIN] Login validation failed');
        return false;
      }

    } catch (error) {
      this.logger.error('âŒ [LOGIN] Login validation error:', error);
      return false;
    }
  }

  // æ‰‹åŠ¨æ£€æŸ¥å½“å‰ä¼šè¯çš„ç™»å½•çŠ¶æ€
  async checkCurrentSessionLogin(): Promise<boolean> {
    if (!this.currentQrSession) {
      return false;
    }

    try {
      // ç®€å•æ£€æŸ¥é¡µé¢æ˜¯å¦è¿˜åœ¨ç™»å½•é¡µé¢
      const currentUrl = this.currentQrSession.page.url();
      const isStillOnLoginPage = currentUrl.includes('signin') || currentUrl.includes('login') || currentUrl.includes('explore');
      
      if (!isStillOnLoginPage) {
        this.logger.log('Page URL changed, user may have logged in');
        
        // è·å–å¹¶ä¿å­˜ cookies
        const cookies = await this.currentQrSession.page.cookies();
        if (cookies.length > 0) {
          await this.saveCookiesToRedis(cookies);
          this.logger.log(`Saved ${cookies.length} cookies after login`);
        }

        // æ›´æ–°ç™»å½•çŠ¶æ€
        const expireDate = new Date();
        expireDate.setDate(expireDate.getDate() + this.COOKIE_EXPIRE_DAYS);
        
        await this.saveLoginStatus({
          isLoggedIn: true,
          lastChecked: new Date(),
          cookiesExpireAt: expireDate,
        });

        // æ¸…ç†ä¼šè¯
        await this.cleanupQrSession();
        
        return true;
      }
      
      return false;
    } catch (error) {
      this.logger.error('Error checking session login:', error);
      return false;
    }
  }

  private async monitorLoginSuccess(page: Page): Promise<void> {
    const timeout = this.configService.get<number>('XHS_LOGIN_TIMEOUT', 120000); // å¢åŠ åˆ°2åˆ†é’Ÿ
    const startTime = Date.now();
    
    this.logger.log('Starting login monitoring...');
    
    try {
      // ä½¿ç”¨è½®è¯¢æ–¹å¼æ£€æŸ¥ç™»å½•çŠ¶æ€ï¼Œæ›´åŠ å¯é 
      const checkInterval = 3000; // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡
      let loginSuccessful = false;
      
      while (Date.now() - startTime < timeout && !loginSuccessful) {
        try {
          // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨ç™»å½•é¡µé¢
          const currentUrl = page.url();
          this.logger.log(`Current URL: ${currentUrl}`);
          
          // å¦‚æœURLå‘ç”Ÿå˜åŒ–ï¼Œå¯èƒ½è¡¨ç¤ºç™»å½•æˆåŠŸ
          if (!currentUrl.includes('signin') && !currentUrl.includes('login')) {
            this.logger.log('URL changed, checking login status...');
            
            // ç­‰å¾…é¡µé¢ç¨³å®š
            await page.waitForTimeout(2000);
            
            // è·å–å¹¶ä¿å­˜cookies
            const cookies = await page.cookies();
            if (cookies.length > 0) {
              await this.saveCookiesToRedis(cookies);
              this.logger.log(`Saved ${cookies.length} cookies to Redis`);
            }
            
            // ä½¿ç”¨å•ç‹¬çš„é¡µé¢éªŒè¯ç™»å½•çŠ¶æ€ï¼Œé¿å…å½±å“å½“å‰é¡µé¢
            const isLoggedIn = await this.checkLoginStatus();
            
            if (isLoggedIn) {
              this.logger.log('âœ… Login successful! Cookies saved.');
              
              const expireDate = new Date();
              expireDate.setDate(expireDate.getDate() + this.COOKIE_EXPIRE_DAYS);
              
              await this.saveLoginStatus({
                isLoggedIn: true,
                lastChecked: new Date(),
                cookiesExpireAt: expireDate,
              });
              
              loginSuccessful = true;
              break;
            }
          }
          
          // æ£€æŸ¥äºŒç»´ç æ˜¯å¦è¿˜å­˜åœ¨
          const qrCodeExists = await page.evaluate(() => {
            const qrSelectors = [
              'img[alt*="äºŒç»´ç "]',
              'img[src*="qrcode"]',
              '.qr-code img',
              '.qrcode img'
            ];
            
            return qrSelectors.some(selector => 
              document.querySelector(selector) !== null
            );
          });
          
          if (!qrCodeExists) {
            this.logger.log('QR code disappeared, login might be successful');
            await page.waitForTimeout(2000); // ç­‰å¾…é¡µé¢ç¨³å®š
            continue; // ç»§ç»­æ£€æŸ¥ç™»å½•çŠ¶æ€
          }
          
          // ç­‰å¾…ä¸‹æ¬¡æ£€æŸ¥
          await page.waitForTimeout(checkInterval);
          
        } catch (error) {
          this.logger.warn('Error during login monitoring:', error);
          await page.waitForTimeout(checkInterval);
        }
      }
      
      if (!loginSuccessful) {
        this.logger.warn('Login monitoring timeout, login may have failed');
      }

    } catch (error) {
      this.logger.error('Login monitoring failed:', error);
    } finally {
      // ä¸åœ¨è¿™é‡Œå…³é—­é¡µé¢ï¼Œç”± cleanupQrSession ç»Ÿä¸€å¤„ç†
      this.logger.log('Login monitoring completed');
    }
  }

  async getAuthenticatedPage(): Promise<Page | null> {
    // å…ˆæ£€æŸ¥ç™»å½•çŠ¶æ€
    this.logger.log('ğŸ” [AUTH_PAGE] Checking login status before creating authenticated page...');
    const isLoggedIn = await this.checkLoginStatus();
    
    if (!isLoggedIn) {
      this.logger.warn('âŒ [AUTH_PAGE] Not logged in, cannot create authenticated page');
      return null;
    }

    const page = await this.browserService.createPage();
    
    try {
      this.logger.log('ğŸ”„ [AUTH_PAGE] Creating authenticated page with saved credentials...');
      
      // åŠ è½½æ‰€æœ‰ä¿å­˜çš„å‡­è¯
      const credentialsLoaded = await this.loadSavedCredentials(page);
      if (!credentialsLoaded) {
        this.logger.warn('âš ï¸ [AUTH_PAGE] Failed to load credentials, page may not be properly authenticated');
      }

      this.logger.log('âœ… [AUTH_PAGE] Authenticated page created successfully');
      return page;
    } catch (error) {
      this.logger.error('âŒ [AUTH_PAGE] Failed to create authenticated page:', error);
      await page.close();
      return null;
    }
  }

  // æ·»åŠ ä¸€ä¸ªæ–¹æ³•æ¥å¼ºåˆ¶é‡æ–°ç™»å½•ï¼ˆæ¸…é™¤cookiesï¼‰
  async forceRelogin(): Promise<void> {
    try {
      // æ¸…ç†å½“å‰ä¼šè¯
      await this.cleanupQrSession();
      
      await this.clearCookiesFromRedis();
      await this.saveLoginStatus({
        isLoggedIn: false,
        lastChecked: new Date(),
      });
      this.logger.log('Forced logout completed, cookies cleared');
    } catch (error) {
      this.logger.error('Failed to force relogin:', error);
    }
  }

  // å¢å¼ºçš„å‡­è¯ä¿å­˜æ–¹æ³•ï¼Œä¿å­˜cookieså’Œstorageæ•°æ®
  private async saveCredentials(page: Page, cookies: any[]): Promise<void> {
    try {
      this.logger.log('ğŸ’¾ [SAVE] Starting credential save process...');

      // 1. ä¿å­˜cookiesåˆ°Redis
      const validCookies = cookies.filter(cookie => cookie.name && cookie.value);
      await this.saveCookiesToRedis(validCookies);
      
      this.logger.log(`ğŸ’¾ [SAVE] Cookies saved: ${validCookies.length} total`);
      validCookies.forEach(cookie => {
        this.logger.log(`  ğŸª ${cookie.name}: ${cookie.value.substring(0, 20)}... (domain: ${cookie.domain})`);
      });

      // 2. è·å–å¹¶ä¿å­˜localStorageæ•°æ®
      const localStorage = await page.evaluate(() => {
        const storage = {};
        for (let i = 0; i < window.localStorage.length; i++) {
          const key = window.localStorage.key(i);
          if (key) {
            storage[key] = window.localStorage.getItem(key);
          }
        }
        return storage;
      });

      if (Object.keys(localStorage).length > 0) {
        await this.redis.setex('xiaohongshu:localStorage', 3600 * 24 * this.COOKIE_EXPIRE_DAYS, JSON.stringify(localStorage));
        this.logger.log(`ğŸ’¾ [SAVE] LocalStorage saved: ${Object.keys(localStorage).length} items`);
        Object.keys(localStorage).forEach(key => {
          const value = localStorage[key];
          this.logger.log(`  ğŸ—ƒï¸ ${key}: ${value ? value.substring(0, 30) + '...' : 'null'}`);
        });
      }

      // 3. è·å–å¹¶ä¿å­˜sessionStorageæ•°æ®
      const sessionStorage = await page.evaluate(() => {
        const storage = {};
        for (let i = 0; i < window.sessionStorage.length; i++) {
          const key = window.sessionStorage.key(i);
          if (key) {
            storage[key] = window.sessionStorage.getItem(key);
          }
        }
        return storage;
      });

      if (Object.keys(sessionStorage).length > 0) {
        await this.redis.setex('xiaohongshu:sessionStorage', 3600 * 24 * this.COOKIE_EXPIRE_DAYS, JSON.stringify(sessionStorage));
        this.logger.log(`ğŸ’¾ [SAVE] SessionStorage saved: ${Object.keys(sessionStorage).length} items`);
        Object.keys(sessionStorage).forEach(key => {
          const value = sessionStorage[key];
          this.logger.log(`  ğŸ“¦ ${key}: ${value ? value.substring(0, 30) + '...' : 'null'}`);
        });
      }

      // 4. ä¿å­˜é¡µé¢çš„åŸºæœ¬ä¿¡æ¯
      const pageInfo = {
        url: page.url(),
        title: await page.title(),
        userAgent: await page.evaluate(() => navigator.userAgent),
        timestamp: new Date().toISOString()
      };
      
      await this.redis.setex('xiaohongshu:pageInfo', 3600 * 24 * this.COOKIE_EXPIRE_DAYS, JSON.stringify(pageInfo));
      this.logger.log(`ğŸ’¾ [SAVE] Page info saved: ${pageInfo.title} (${pageInfo.url})`);

      this.logger.log('âœ… [SAVE] All credentials saved successfully to Redis!');
      this.logger.log(`ğŸ•’ [SAVE] Credentials will expire in ${this.COOKIE_EXPIRE_DAYS} days`);

    } catch (error) {
      this.logger.error('âŒ [SAVE] Failed to save credentials:', error);
      throw error;
    }
  }

  // ä½¿ç”¨æ–°é¡µé¢éªŒè¯ç™»å½•çŠ¶æ€
  private async verifyLoginWithNewPage(cookies: any[]): Promise<boolean> {
    let testPage: Page | null = null;
    
    try {
      this.logger.log('ğŸ” [VERIFY] Creating test page to verify login...');
      testPage = await this.browserService.createPage();
      
      // è®¾ç½®cookies
      await testPage.setCookie(...cookies);
      this.logger.log(`ğŸ” [VERIFY] Applied ${cookies.length} cookies to test page`);
      
      // è®¿é—®éœ€è¦ç™»å½•çš„é¡µé¢
      await testPage.goto(this.XHS_LOGIN_URL, { waitUntil: 'networkidle2', timeout: 30000 });
      await testPage.waitForTimeout(2000);
      
      // ä½¿ç”¨ç²¾ç¡®çš„XPathæ£€æŸ¥æ˜¯å¦ä»éœ€è¦ç™»å½•
      const needsLogin = await this.isLoginRequired(testPage);
      
      this.logger.log(`ğŸ” [VERIFY] Login verification result: ${needsLogin ? 'FAILED - still needs login' : 'SUCCESS - logged in'}`);
      
      return !needsLogin;
      
    } catch (error) {
      this.logger.error('âŒ [VERIFY] Login verification failed:', error);
      return false;
    } finally {
      if (testPage) {
        await testPage.close();
        this.logger.log('ğŸ” [VERIFY] Test page closed');
      }
    }
  }

  // åŠ è½½ä¿å­˜çš„å‡­è¯åˆ°é¡µé¢
  private async loadSavedCredentials(page: Page): Promise<boolean> {
    try {
      this.logger.log('ğŸ”„ [LOAD] Loading saved credentials...');

      // 1. åŠ è½½cookies
      const cookies = await this.loadCookiesFromRedis();
      if (cookies && cookies.length > 0) {
        await page.setCookie(...cookies);
        this.logger.log(`ğŸ”„ [LOAD] Loaded ${cookies.length} cookies`);
      }

      // 2. åŠ è½½localStorage
      try {
        const localStorageStr = await this.redis.get('xiaohongshu:localStorage');
        if (localStorageStr && typeof localStorageStr === 'string') {
          const localStorage = JSON.parse(localStorageStr);
          await page.evaluateOnNewDocument((storage) => {
            for (const [key, value] of Object.entries(storage)) {
              window.localStorage.setItem(key, value as string);
            }
          }, localStorage);
          this.logger.log(`ğŸ”„ [LOAD] Loaded ${Object.keys(localStorage).length} localStorage items`);
        }
      } catch (error) {
        this.logger.warn('âš ï¸ [LOAD] Failed to load localStorage:', error);
      }

      // 3. åŠ è½½sessionStorage  
      try {
        const sessionStorageStr = await this.redis.get('xiaohongshu:sessionStorage');
        if (sessionStorageStr && typeof sessionStorageStr === 'string') {
          const sessionStorage = JSON.parse(sessionStorageStr);
          await page.evaluateOnNewDocument((storage) => {
            for (const [key, value] of Object.entries(storage)) {
              window.sessionStorage.setItem(key, value as string);
            }
          }, sessionStorage);
          this.logger.log(`ğŸ”„ [LOAD] Loaded ${Object.keys(sessionStorage).length} sessionStorage items`);
        }
      } catch (error) {
        this.logger.warn('âš ï¸ [LOAD] Failed to load sessionStorage:', error);
      }

      this.logger.log('âœ… [LOAD] All saved credentials loaded successfully');
      return true;

    } catch (error) {
      this.logger.error('âŒ [LOAD] Failed to load saved credentials:', error);
      return false;
    }
  }

  // æ¸…ç†æ‰€æœ‰è®¤è¯ç›¸å…³çš„ Redis æ•°æ®
  async clearAllAuthData(): Promise<void> {
    try {
      await this.redis.del(this.REDIS_KEY);
      await this.redis.del(this.COOKIES_KEY);
      await this.redis.del('xiaohongshu:localStorage');
      await this.redis.del('xiaohongshu:sessionStorage');
      await this.redis.del('xiaohongshu:pageInfo');
      this.logger.log('ğŸ—‘ï¸ [CLEAR] Cleared all authentication data from Redis');
    } catch (error) {
      this.logger.error('âŒ [CLEAR] Failed to clear auth data from Redis:', error);
    }
  }

  // æ£€æŸ¥å½“å‰äºŒç»´ç ä¼šè¯æ˜¯å¦æœ‰æ•ˆ
  private isQrSessionValid(): boolean {
    if (!this.currentQrSession) {
      return false;
    }

    // æ£€æŸ¥é¡µé¢æ˜¯å¦ä»ç„¶å­˜æ´»
    if (this.currentQrSession.page.isClosed()) {
      this.logger.log('QR session invalid: page is closed');
      this.currentQrSession = null;
      return false;
    }

    // æ£€æŸ¥äºŒç»´ç æ˜¯å¦è¿‡æœŸ
    const now = new Date();
    const elapsed = now.getTime() - this.currentQrSession.createdAt.getTime();
    if (elapsed > this.QR_CODE_EXPIRE_TIME) {
      this.logger.log('QR session invalid: expired');
      return false;
    }

    return true;
  }

  // ç²¾ç¡®æ£€æµ‹æ˜¯å¦éœ€è¦ç™»å½•ï¼ˆä½¿ç”¨ç‰¹å®šXPathï¼‰
  private async isLoginRequired(page: Page): Promise<boolean> {
    try {
      // æ£€æŸ¥ç™»å½•ç•Œé¢ç‰¹æœ‰çš„å…ƒç´ æ˜¯å¦å­˜åœ¨
      const loginElements = await page.$x(this.LOGIN_CHECK_XPATH);
      
      if (loginElements.length > 0) {
        // è¿›ä¸€æ­¥éªŒè¯å…ƒç´ å†…å®¹æ˜¯å¦åŒ…å«"æ‰‹æœºå·ç™»å½•"
        const elementText = await page.evaluate((element) => {
          return element ? element.textContent || '' : '';
        }, loginElements[0]);
        
        const isLoginPage = elementText.includes('æ‰‹æœºå·ç™»å½•');
        this.logger.log(`ğŸ” [LOGIN_CHECK] Login element found: ${loginElements.length > 0}, Text: "${elementText}", Is login page: ${isLoginPage}`);
        
        return isLoginPage;
      } else {
        this.logger.log('ğŸ” [LOGIN_CHECK] Login element not found - user appears to be logged in');
        return false;
      }
    } catch (error) {
      this.logger.warn('âš ï¸ [LOGIN_CHECK] Error checking login status:', error);
      return true; // å‡ºé”™æ—¶å‡è®¾éœ€è¦ç™»å½•ï¼Œå®‰å…¨å¤„ç†
    }
  }

  // æ¸…ç†å½“å‰äºŒç»´ç ä¼šè¯
  private async cleanupQrSession(): Promise<void> {
    if (this.currentQrSession) {
      try {
        if (!this.currentQrSession.page.isClosed()) {
          await this.currentQrSession.page.close();
        }
      } catch (error) {
        this.logger.warn('Error closing QR session page:', error);
      }
      this.currentQrSession = null;
      this.logger.log('QR session cleaned up');
    }
  }
}